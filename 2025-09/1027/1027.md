# 📝 알고리즘 문제 풀이 - 2025-10-27

## 문제 📖

- **문제 링크:** [프로그래머스 - 여행경로](https://school.programmers.co.kr/learn/courses/30/lessons/43164)

- **문제 유형:** dfs/bfs

- **난이도:** 레벨3

- **풀이 시간:** ⏳ 40분

## ✍ 첫번째 접근 방식

### 1. 기존 풀이 (모든 경로 탐색 후 정렬)

- 접근 방법: DFS + 백트래킹 (Brute Force)
- 핵심 로직:

  - 주어진 모든 티켓을 사용하여 "ICN"에서 출발하는 가능한 모든 경로를 찾습니다.
  - DFS를 수행하면서, 티켓 사용 여부를 별도의 visited 배열(혹은 Map)을 통해 관리합니다.
  - 하나의 완성된 경로(모든 티켓 사용)를 찾으면, 이 경로를 answer 배열에 저장합니다.
  - 탐색이 끝나면 visited를 다시 false로 되돌려(백트래킹), 다른 가능한 경로를 계속 탐색합니다.

- 정답 도출:

  - DFS 탐색이 모두 끝난 후, answer 배열에는 가능한 모든 여행 경로가 담겨 있습니다.
  - 이 answer 배열을 알파벳순으로 정렬(answer.sort())합니다.
  - 정렬된 배열의 첫 번째 요소(answer[0])를 최종 정답으로 반환합니다.

- 특징: "일단 모든 답을 구하고, 그중에서 가장 좋은 답(알파벳순)을 고른다"는 방식입니다. 이해하기는 쉽지만, 가능한 경로가 많아질수록 비효율적입니다.

## 두번째 접근 방식

### 2, 개선된 풀이

- 접근 방법: DFS + 스택
- 핵심 로직:
  - 그래프를 생성할 때, 각 출발지에서 갈 수 있는 도착지 목록을 미리 알파벳순으로 정렬합니다.
  - stack에 시작점 "ICN"을 넣고 탐색을 시작합니다. stack은 현재 탐색 중인 경로를 의미합니다.
  - stack의 맨 위(current)에서 출발하는 경로를 찾습니다.
  - 이때, 항상 알파벳순으로 가장 앞서는 경로(graph[current].shift())를 탐욕적으로(Greedy) 선택합니다.
  - 사용한 티켓(경로)은 그래프에서 즉시 제거(shift())합니다. (이것이 visited 배열을 대체합니다.)
- 정답 도출:
  - 탐색 중 current에서 더 이상 갈 곳이 없는 막다른 길에 도착하면, current를 stack에서 pop하여 route라는 별도 배열에 추가합니다.
  - 이 과정은 stack이 빌 때까지 반복됩니다. (결과적으로 route에는 경로의 끝부분부터 역순으로 저장됩니다.)
  - stack이 모두 비면, route 배열을 뒤집어서(reverse()) 반환합니다.
- 특징: "항상 알파벳순으로 가장 앞서는 경로를 먼저 간다"는 전략을 사용합니다. 만약 잘못된 길(나중에 티켓을 다 못 쓰게 되는 길)로 가더라도, 결국 막다른 길에서 pop되어 route의 앞쪽(뒤집으면 뒤쪽)에 배치됩니다. 정답이 되는 경로는 가장 늦게 pop 되므로, 단 한 번의 탐색으로 정렬 없이 알파벳순으로 가장 앞서는 경로를 찾을 수 있습니다.
