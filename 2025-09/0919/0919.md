# 📝 알고리즘 문제 풀이 - 2025-09-19

## 문제 📖

- **문제 링크:** [백준 - 색칠 1](https://www.acmicpc.net/problem/1117)

- **문제 유형:** 구현, 수학

- **난이도:** 골드5

- **풀이 시간:** ⏳ 1시간반

## ✍ 접근 방식

### 시간/공간 복잡도

둘 다 모두 **O(1)**

- BigInt 연산들도 상수 시간에 수행됨

### BigInt 써야하는 이유

곱셈 과정에서 최대 10⁹ × 10⁹ × 1000 ≈ 10²¹ 까지 커질 수 있어서, 2³¹−1이나 2⁵³−1 범위를 넘을 수 있으므로 [BigInt](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt)가 필요

### `Math.min(f, W - f)` 이렇게 못하는 이유

- Math.min()은 일반 JavaScript Number 타입만 처리함
- BigInt는 Number와 다른 타입이므로 Math.min()에 전달하면 런타임 에러(TypeError) 발생

### `answer.toString()` 하는 이유

- BigInt 타입 때문
  - JavaScript에서 BigInt는 일반 숫자와 다른 타입이므로, 출력할 때 명시적으로 문자열로 변환해야 함
- 온라인 저지 호환성
  - 백준, 프로그래머스 같은 온라인 저지에서는 출력 형식을 엄격하게 체크하는데, BigInt를 그대로 출력하면 형식 오류가 발생할 수 있음
- 안전한 출력
  - toString()을 사용하면 확실히 문자열 형태로 출력되어 어떤 환경에서도 안전하게 동작함

### 코드 설명

1. `const overlapWidth = f < W - f ? f : W - f;`

   종이를 접으면 왼쪽 영역과 오른쪽 영역 중 작은 쪽이 겹쳐짐
   따라서 overlapWidth = min(f, W-f) = 겹쳐지는 부분의 너비

2. `if (overlapWidth <= x1)`

   색칠 영역이 접히는 영역 바깥쪽에만 존재한다면?
   → 단순히 (c+1)번 겹쳐진 만큼 칠해짐

3. `else if (overlapWidth < x2)`

   색칠 영역이 접히는 영역과 일부 겹칠 때
   → 영역을 겹친 부분과 겹치지 않는 부분으로 나눔

   ```js
   // 접히는 영역에 겹치는 부분은 2배로 칠해짐
   answer -= (overlapWidth - x1) * paintH * (c + 1n) * 2n;

   // 그 외 영역은 1배만 칠해짐
   answer -= (x2 - overlapWidth) * paintH * (c + 1n);
   ```

4. `else`

   색칠 영역 전체가 접히는 부분 안쪽이라면?
   → 색칠된 게 모두 2배로 적용됨
