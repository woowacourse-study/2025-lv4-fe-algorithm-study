# 📝 알고리즘 문제 풀이 - 2025-09-11

## 문제 📖

- **문제 링크:** [프로그래머스 - 땅따먹기](https://school.programmers.co.kr/learn/courses/30/lessons/12913)

- **문제 유형:** (?)

- **난이도:** (Lv.2)

- **풀이 시간:** ⏳ (40분)

## ✍ 접근 방식

- 처음 방식

```js
function solution(land) {
  let firstNum = [];
  let secondNum = [];
  let thirdNum = [];

  const firstMaxNumFn = () => {
    for (let i = 0; i < land[0].length; i++) {
      const a = land[0][i];
      firstNum.push(a);
    }
    return Math.max(...firstNum);
  };

  const firstMaxNum = firstMaxNumFn();
  //첫번째 행의 가장 큰값의 index를 찾아
  const firstMaxNumIndex = land[0].findIndex((num) => num === firstMaxNum);

  const secondMaxNumFn = () => {
    //두번째 행에서 firstMaxNumIndex와 똑같은 index를 제외하고 가장 큰 수를 찾자.
    for (let i = 0; i < land[1].length; i++) {
      const a = land[1][i];
      secondNum.push(a);
    }
    const secondNumCopy = secondNum.slice();
    secondNumCopy.splice(firstMaxNumIndex, 1);

    console.log('firstMaxNumIndex', firstMaxNumIndex);
    console.log('secondNum', secondNum);
    return Math.max(...secondNumCopy);
  };

  const secondMaxNum = secondMaxNumFn();
  const secondMaxNumIndex = land[1].findIndex((num) => num === secondMaxNum);

  const thirdMaxNumFn = () => {
    //세번째 행에서 secondMaxNumIndex와 똑같은 index를 제외하고 가장 큰 수를 찾자
    for (let i = 0; i < land[2].length; i++) {
      const a = land[2][i];
      thirdNum.push(a);
    }
    thirdNum.splice(secondMaxNumIndex, 1);
    return Math.max(...thirdNum);
  };

  const thirdMaxNum = thirdMaxNumFn();

  return firstMaxNum + secondMaxNum + thirdMaxNum;
}
```

- 답지 방식

```js
function solution(land) {
  for (let i = 1; i < land.length; i++) {
    land[i][0] += Math.max(land[i - 1][1], land[i - 1][2], land[i - 1][3]);
    land[i][1] += Math.max(land[i - 1][0], land[i - 1][2], land[i - 1][3]);
    land[i][2] += Math.max(land[i - 1][0], land[i - 1][1], land[i - 1][3]);
    land[i][3] += Math.max(land[i - 1][0], land[i - 1][1], land[i - 1][2]);
  }
  return Math.max(...land[land.length - 1]);
}
```

- DP라는 개념을 배우고 일요일쯤 다시 풀어야할 것 같네요...
