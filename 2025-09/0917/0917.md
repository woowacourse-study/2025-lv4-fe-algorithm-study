# 📝 알고리즘 문제 풀이 - 2025-09-17

## 문제 📖

- **문제 링크:** [백준 - 스티커](https://www.acmicpc.net/problem/9465)

- **문제 유형:** DP

- **난이도:** 실버1

- **풀이 시간:** ⏳ 1시간

## ✍ 접근 방식

기존 풀이로 했었는데 틀렸다고 함.
기존에는 같은 행의 n-2, 다른 행의 n-1 만 접근했음
다시 보니까, 다른 행의 n-1, n-2만 접근해야 함

### 기존 풀이 (틀린 점화식)

```javascript
dp[0][n] = Math.max(dp[0][n - 2], dp[1][n - 1]) + A[n];
dp[1][n] = Math.max(dp[1][n - 2], dp[0][n - 1]) + B[n];
```

### 올바른 풀이 (맞는 점화식)

```javascript
dp[0][n] = Math.max(dp[1][n - 1], dp[1][n - 2]) + A[n];
dp[1][n] = Math.max(dp[0][n - 1], dp[0][n - 2]) + B[n];
```

# 기존 풀이가 틀리고 지금 풀이가 맞는 이유

**스티커 배치:**

```
[50] [10] [100] [20] [40]  ← 첫 번째 행
[30] [50] [70]  [10] [60]  ← 두 번째 행
```

**dp[1][1] = 50의 의미:**

- `dp[1][1]`은 `[50]` (두 번째 행의 두 번째 스티커)를 선택했을 때의 최댓값
- `[50]`을 선택하면 `[10]` (첫 번째 행의 두 번째 스티커)는 **선택할 수 없음** (인접하므로)

## 왜 같은 행의 2칸 떨어진 스티커를 선택하는 것이 문제인가?

**잘못된 점화식:**

```javascript
dp[0][2] = Math.max(dp[0][0], dp[1][1]) + 100;
```

**이것의 의미:**

1. `dp[0][0] + 100`: `[50]`을 선택하고 `[100]`을 선택
2. `dp[1][1] + 100`: `[50]`을 선택하고 `[100]`을 선택

**문제점:**

- `dp[0][0]`을 선택하면 `[10]`은 선택할 수 없음 (인접하므로)
- `dp[1][1]`을 선택해도 `[10]`은 선택할 수 없음 (인접하므로)
- **둘 다 `[10]`을 선택할 수 없는데, 왜 비교하는가?**

**올바른 점화식:**

```javascript
dp[0][2] = Math.max(dp[1][1], dp[1][0]) + 100;
```

**이것의 의미:**

1. `dp[1][1] + 100`: `[50]`을 선택하고 `[100]`을 선택
2. `dp[1][0] + 100`: `[30]`을 선택하고 `[100]`을 선택

**왜 이것이 올바른가?**

- `dp[1][1]`을 선택하면 `[10]`은 선택할 수 없음 (인접하므로)
- `dp[1][0]`을 선택하면 `[10]`을 선택할 수 있음 (인접하지 않으므로)
- 이 두 경우를 비교하는 것이 의미가 있음

## 정리

- `dp[1][0]`을 선택하면 `[10]`을 선택할 수 있습니다 (인접하지 않으므로)
- `dp[1][1]`을 선택하면 `[10]`은 선택할 수 없습니다 (인접하므로)
- 따라서 `dp[1][0]`과 `dp[1][1]`을 비교하는 것이 의미가 있습니다
