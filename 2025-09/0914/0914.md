# 📝 알고리즘 문제 풀이 - 2025-09-08

## 문제 📖

- **문제 링크:** [프로그래머스 - 기둥과 보 설치](https://school.programmers.co.kr/learn/courses/30/lessons/60061)

- **문제 유형:** (구현)

- **난이도:** (Lv.3)

- **풀이 시간:** ⏳ (50분)

## ✍ 접근 방식

처음 구조물 설치의 접근
```js
if(isAdd)
  {
  if(isBo) {
    if(findArrayInAnswer([x, y - 1, 0])) answer.push([x, y, 1]);
    if(findArrayInAnswer([x + 1, y - 1, 0])) answer.push([x, y, 1]);
    if((findArrayInAnswer([x + 1, y, 1]) && findArrayInAnswer([x - 1, y, 1]))) answer.push([x, y, 1]);
  } else {
    if(y === 0) answer.push([x, y, 0]);
    if(findArrayInAnswer([x, y - 1, 0])) answer.push([x, y, 0]);
    if(findArrayInAnswer([x - 1, y, 1])) answer.push([x, y, 0]);
  }
}
```

- 설치 가능한지 모두 판단한 다음에 설치
- 설치 가능한지가 결국 설치했을 때 잘 연결되는지이기 때문에
- `isConnect`를 `for` 문으로 하나하나 설치 가능한지와 같은 validate로 검증한다.
- 그래서 위 생각을 바탕으로 `validPillar`, `validBo`, `isConnect` 함수 구현하였다.
- 그래서 처음에는 설치 가능한지를 보고 추가를 하였지만,
- 변경된 로직은 설치/삭제를 하도 isConnect를 판단한 다음에 false이면 이전 상태로 돌리는 식으로 구현하였다.

### 문법 기억하기

```js
// before
answer.sort((a, b) => a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : a[1] - b[1])

// after
answer.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]) || (a[2] - b[2]))
```

```js
// before
const exists = (arr) => answer.filter(([ax, ay, at]) => ax === arr[0] && ay === arr[1] && at === arr[2]).length === 1;

// after
const exists = (x, y, t) => answer.some(([ax, ay, at]) => ax === x && ay === y && at === t);
```