# 📝 알고리즘 문제 풀이 - 2025-10-07

## 문제 📖

- **문제 링크:** [프로그래머스 - 두큐합같게만들기](https://school.programmers.co.kr/learn/courses/30/lessons/118667#)

- **문제 유형:** 슬라이딩 윈도우, 투 포인터

- **난이도:** 레벨2

- **풀이 시간:** ⏳ 25분

## ✍ 접근 방식

'투 포인터를 활용한 그리디 슬라이딩 윈도우' 전략입니다.

## 핵심 접근 방식 정리

1. 데이터 구조: 하나의 원형 큐로 변환 💡

const queue = [...queue1, ...queue2]

가장 먼저 두 큐를 하나의 긴 배열로 합쳤습니다. 이는 두 큐 사이에서 원소를 실제로 옮기는(배열에서 원소를 빼고 추가하는) 비효율적인 작업을 피하기 위함입니다.

이 합쳐진 배열을 **하나의 거대한 원형 큐(Circular Queue)**처럼 사용하여, 포인터만 이동시키는 방식으로 pop과 insert 연산을 흉내 냅니다.

2. 알고리즘: 투 포인터와 슬라이딩 윈도우 ⚙️

start1과 end1이라는 두 개의 **포인터(인덱스)**를 사용합니다.

이 두 포인터는 합쳐진 배열 위에서 queue1에 해당하는 **구간(Window)**을 정의합니다. start1은 queue1의 시작, end1은 queue1의 끝을 가리킵니다.

queue1에서 원소를 빼는(pop) 작업은 start1 포인터를 오른쪽으로 한 칸 이동시키는 것(start1 += 1)으로 처리합니다.

다른 큐의 원소를 queue1에 넣는(insert) 작업은 end1 포인터를 오른쪽으로 한 칸 이동시키는 것(end1 += 1)으로 처리합니다.

이렇게 포인터를 움직이며 구간을 줄이거나 늘리는 방식을 **슬라이딩 윈도우(Sliding Window) 기법**이라고 합니다.

3. 전략: 그리디(Greedy) 접근법 🎯

// queue1의 합이 ... 작으면 insert

// queue1의 합이 ... 크면 pop

주석에 명확히 나타나 있듯이, **매 순간 목표값(sum / 2)에 도달하기 위한 가장 명확한 선택**을 합니다.

현재 합 < 목표값: 합을 늘려야 하므로, 다른 큐에서 원소를 가져옵니다.

현재 합 > 목표값: 합을 줄여야 하므로, 현재 큐에서 원소를 내보냅니다.

이처럼 매 순간 최적이라고 생각되는 선택을 하는 방식을 그리디 알고리즘이라고 합니다. 이 문제에서는 이 방법이 항상 최단 경로를 보장합니다.

4. 종료 조건: 명확한 성공 및 실패 처리 🛡️

// queue를 다 돌고 원래의 queue1, queue2로 돌아와도 ... 만들 수가 없는 것

성공 조건: sum1이 목표값과 정확히 일치하면 그 즉시 연산 횟수를 반환하고 종료합니다.

실패 조건: while(cnt <= queue.length \* 2)를 통해 예외 상황을 처리했습니다. 모든 원소가 제자리를 한 바퀴 이상 돌아올 정도로 충분히 많이 시도했는데도 답을 찾지 못했다면, 합을 같게 만드는 것이 불가능하다고 판단하고 -1을 반환합니다. 이는 무한 루프를 방지합니다.

요약하자면, 두 큐를 하나로 합쳐 원형 큐처럼 만들고, 그 위에서 투 포인터를 이용해 queue1을 슬라이딩 윈도우로 표현하며, 매 순간 목표값에 가까워지는 그리디 전략으로 최소 연산 횟수를 찾아내는 방식이라고 정리할 수 있습니다.
