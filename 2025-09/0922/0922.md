# 📝 알고리즘 문제 풀이 - 2025-09-22

## 문제 📖

- **문제 링크:** [prog - 순위 검색](https://school.programmers.co.kr/learn/courses/30/lessons/72412)

- **문제 유형:**

- **난이도:** lv2

- **풀이 시간:** ⏳ 50분

## ✍ 접근 방식

> 어떤 방법으로 접근했는지 설명
> 다른 풀이를 참고했다면 어떤걸 배웠는지

### 문제상황

query 배열의 크기 1 - 100,000
info 배열의 크기 1 - 50,000
현재 시간 복잡도 O(N^2)
최악의 경우 5초 이상 걸림
! 정확도는 해결하지만 효율성을 해결하지못함.

```js
function solution(info, query) {
  var answer = [];
  query.forEach((q) => {
    const [lang, position, career, foodNscore] = q.split(' and ');
    const [food, score] = foodNscore.split(' ');
    const filtered = info.filter((i) => {
      const [la, po, ca, fd, sc] = i.split(' ');
      return (
        (la === lang || lang === '-') &&
        (po === position || position === '-') &&
        (ca === career || career === '-') &&
        (fd === food || food === '-') &&
        Number(sc) >= Number(score)
      );
    });
    answer.push(filtered.length);
  });
  return answer;
}
```

### 개선 방안

효율성은 '매쿼리마다 info 전체를 훑는 O(Q,N) 구조 때문에 깨짐.
핵심 아이디어 : 전처리 + 이진 탐색

1. info 배열의 지원자는 4개의 속성을 가짐. (언어,직군,경력,음식)
   배열 전처리 (O(N\*16))
2. 배열 전처리 이후 각 키의 점수 배열을 정렬
3. 쿼리는 " and " 를 제거해 4속성 + 점수로 만들고 해당 키의 점수 배열에서 score 이상이 시작되는 인덱스를 이진 탐색으로 찾음. (O(Q·logK))

N=5만, Q=10만
