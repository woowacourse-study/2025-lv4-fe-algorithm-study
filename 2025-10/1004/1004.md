# 📝 알고리즘 문제 풀이 - 2025-10-04

## 문제 📖

- **문제 링크:** [prog - 외벽 점검](https://school.programmers.co.kr/learn/courses/30/lessons/60062)

- **문제 유형:**

- **난이도:** Lv.3

- **풀이 시간:** ⏳ (예: 30분- 실제 걸렸던 시간)

## ✍ 접근 방식

- (어떤 방법으로 접근했는지 설명)
- (다른 풀이를 참고했다면 어떤걸 배웠는지)

### 풀이 방식

1. 원형(0 ~ n)을 직선화: weak 배열을 두 번 이어 붙여서 weak[i + len] = weak[i] + n 으로 확장. 이렇게 하면 어떤 시작점에서든 연속 구간으로 커버 가능.

2. 친구들(dist)의 모든 순열을 만든 뒤,
   각 시작 취약지점과 각 순열에 대해 그리디하게 커버:

첫 번째 친구가 커버할 수 있는 끝 위치 coverEnd = startWeak + dist[0].

그 범위를 벗어나는 첫 취약 지점에서 다음 친구 투입, coverEnd 갱신.

필요한 친구 수를 세어 최소값 갱신.

3. 최소 친구 수가 dist.length를 넘으면 불가능 → -1.

### 핵심

- 선형으로 펼치기 : extended = weak + (weak의 각 원소 + n)
  - 그리고 시작 인덱스를 0..wLen-1로 바꾸며 길이 wLen 구간만 검사.
- 그리디 : 항상 현재 친구로 가능한 한 멀리까지 커버한 뒤, 못 덮는 지점에서만 다음 친구를 씀.
- 답: 모든 조합에서 나온 값의 최솟값, 하나도 성공 못 하면 -1.
