# 📝 알고리즘 문제 풀이 - 2025-10-03

## 문제 📖

- **문제 링크:** [프로그래머스 - 양과늑대](https://school.programmers.co.kr/learn/courses/30/lessons/92343)

- **문제 유형:** (dfs, 백트래킹)

- **난이도:** (예: 레벨3)

- **풀이 시간:** ⏳ (예: 3시간~?)

## ✍ 접근 방식

- 백트래킹 문제라는건 문제 읽으면서 알았는데, **다른 노드를 들름으로써 원래는 가지 못할 노드에 방문**할 가능성을 구현하는게 너무너무 어려워서 + 생각하다가 포기함...
- 그래서 첫 시도는 stack + queue 두개를 사용해서 분기가 일어날 수 있는 곳마다 queue에 push 해서 저장하는 방밥을 사용했는데, 그렇게 하니까 예제 문제는 통과함!
- 근데 문제 제출했을 때 틀리는 케이스가 있었다.. 아마 제대로된 알고리즘이 아니여서 그렇겠지 ~

- 결국 AI의 도움을 받아서 피드백을 받음.
- 정답코드에서 핵심 부분은 아래 반복문 부분인 것 같다.
- 방문하려는 노드를 제외하고, 현재 방문할 수 있는 모든 노드를 탐색하면서 경우의 수를 찾는 부분!
- 아마 n의 개수가 17개밖에 없어서 가능했던 로직인 것 같기도 하다. 아니였으면 분명 시간초과 걸렸을지도....

```jsx
for (let i = 0; i < newNextNodes.length; i++) {
  const next = newNextNodes[i];
  dfs(
    sheep,
    wolf,
    next,
    newNextNodes.filter((_, idx) => idx !== i)
  );
}
```
