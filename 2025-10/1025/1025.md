# 📝 알고리즘 문제 풀이 - 2025-10-25

## 문제 📖

- **문제 링크:** [백준 - 보석 상자](https://www.acmicpc.net/problem/2792)

- **문제 유형:** 이분탐색

- **난이도:** 실버1

- **풀이 시간:** ⏳ 1시간반

## 예시 설명

입력: N=7, M=5, 보석=[7, 1, 7, 4, 4]
정렬 후: [1, 4, 4, 7, 7]

질투심이 3일 때:

- 1개 보석: 1/3 = 0명 + 나머지 1개 → 1명 필요
- 4개 보석: 4/3 = 1명 + 나머지 1개 → 2명 필요
- 4개 보석: 4/3 = 1명 + 나머지 1개 → 2명 필요
- 7개 보석: 7/3 = 2명 + 나머지 1개 → 3명 필요
- 7개 보석: 7/3 = 2명 + 나머지 1개 → 3명 필요

=> 총 11명 필요 → 7명보다 많음 → 질투심을 더 크게 설정

질투심이 4일 때:

- 1개 보석: 1/4 = 0명 + 나머지 1개 → 1명 필요
- 4개 보석: 4/4 = 1명 + 나머지 0개 → 1명 필요
- 4개 보석: 4/4 = 1명 + 나머지 0개 → 1명 필요
- 7개 보석: 7/4 = 1명 + 나머지 3개 → 2명 필요
- 7개 보석: 7/4 = 1명 + 나머지 3개 → 2명 필요

=> 총 7명 필요 → 7명과 같음 → 질투심 4가 답!

## ✍ 접근 방식

시간 복잡도: O(M × log(max_jewel))
공간 복잡도: O(M)

문제 핵심:

- N명의 아이들에게 M가지 색의 보석을 나눠주기
- 각 아이가 받는 보석의 최대 개수를 "질투심"이라고 함
- 질투심의 최솟값을 구하는 문제

질투심 범위: 1 ~ (가장 많은 보석의 개수)

- 중간값을 질투심으로 설정하고 모든 보석을 나눠줄 수 있는지 확인
- 가능하면 질투심을 더 작게, 불가능하면 더 크게 설정

핵심 로직:

```javascript
// 각 보석 종류별로 필요한 아이의 수 계산
count += Math.floor(jewel[i] / mid); // 정수 나눗셈
if (jewel[i] % mid) count++; // 나머지가 있으면 한 명 더 필요
```

JavaScript vs C++ 차이점:

- 정수 나눗셈: C++는 자동, JavaScript는 Math.floor() 필요
- 이진 탐색 조건: while (left <= right) 사용
- 포인터 업데이트: left = mid + 1, right = mid - 1

`Math.floor()`를 사용하는 이유

C++에서는 **정수끼리 나눗셈할 때 자동으로 소수점 이하를 버림** (정수 나눗셈)
JavaScript에서는 **모든 나눗셈이 부동소수점 나눗셈임**

- N=7, M=5
- 보석: [1, 4, 4, 7, 7] (정렬 후)

만약 mid=3이라고 하면:

**C++ 방식 (정수 나눗셈):**

- 1 / 3 = 0
- 4 / 3 = 1
- 4 / 3 = 1
- 7 / 3 = 2
- 7 / 3 = 2

**JavaScript 방식 (부동소수점 나눗셈):**

- 1 / 3 = 0.333... → 0.333... (소수점 포함)
- 4 / 3 = 1.333... → 1.333... (소수점 포함)
- 4 / 3 = 1.333... → 1.333... (소수점 포함)
- 7 / 3 = 2.333... → 2.333... (소수점 포함)
- 7 / 3 = 2.333... → 2.333... (소수점 포함)

**문제의 핵심:** JavaScript에서 `jewel[i] / mid`는 소수점을 포함한 값이므로, 이를 정수로 변환해야 함

```javascript
// Math.floor() 없이:
count += jewel[i] / mid; // 1.333... 같은 값이 누적됨

// Math.floor() 사용:
count += Math.floor(jewel[i] / mid); // 1, 2 같은 정수값이 누적됨
```

2번째 케이스에 대하여,

- **Math.floor() 사용**: 결과 = 4
- **Math.floor() 없이**: 결과 = 7

왜 이런 차이가 발생하는가?

**Math.floor() 없이 실행할 때:**

- `count` 변수에 소수점이 포함된 값들이 누적됨
- 예: `1.333 + 1.333 + 1.333 + 2.333 + 2.333 = 8.665`
- 이 값이 `N=7`보다 크므로 다른 경로로 이진 탐색이 진행됨

**Math.floor() 사용할 때:**

- `count` 변수에 정수값만 누적됨
- 예: `1 + 1 + 1 + 2 + 2 = 7`
- C++ 코드와 동일한 로직으로 동작함

경계 케이스에서의 차이도 존재하는데,
예를 들어 `5/3 = 1.666...`인 경우:

- C++ 정수 나눗셈: 5/3 = 1 (내림)
- Math.floor(): Math.floor(5/3) = 1 (내림) ✅
- Math.round(): Math.round(5/3) = 2 (반올림) ❌

---

## 두 가지 이진 탐색 패턴

### **패턴 1: `while (left <= right)` + `left = mid + 1, right = mid - 1`**

```javascript
while (left <= right) {
  const mid = Math.floor((left + right) / 2);
  if (condition) {
    right = mid - 1;
  } else {
    left = mid + 1;
  }
}
// 답: left
```

### **패턴 2: `while (left < right)` + `left = mid + 1, right = mid`**

```javascript
while (left < right) {
  const mid = (left + right) >> 1;
  if (condition) {
    right = mid;
  } else {
    left = mid + 1;
  }
}
// 답: left
```

## 실제 동작 비교

현재 input.txt로 두 방식을 비교해보겠습니다:

[1 tool called]

## 핵심 차이점

### **1. 종료 조건**

- **패턴 1**: `left <= right` → `left > right`일 때 종료
- **패턴 2**: `left < right` → `left >= right`일 때 종료

### **2. 포인터 업데이트**

- **패턴 1**: `right = mid - 1` (mid를 제외)
- **패턴 2**: `right = mid` (mid를 포함)

### **3. 무한 루프 방지**

- **패턴 1**: `left = mid + 1`로 항상 범위가 줄어듦
- **패턴 2**: `right = mid`로 범위가 줄어들지 않을 수 있음 → `left < right` 조건으로 무한 루프 방지

## 왜 다른 조건을 사용하는가?

### **패턴 1의 특징:**

- **전통적인 이진 탐색**
- **범위를 확실히 줄임** (`mid ± 1`)
- **조건이 복잡할 때 안전**

### **패턴 2의 특징:**

- **최적화된 이진 탐색**
- **더 적은 비교 횟수** (경우에 따라)
- **조건이 단순할 때 효율적**

## 실제로는 동일한 결과

두 패턴 모두 **같은 답을 찾지만**, **내부 동작 방식이 다릅니다**:

1. **패턴 1**: 범위를 확실히 줄이면서 탐색
2. **패턴 2**: 가능한 답을 유지하면서 탐색

## 결론

**두 조건문이 다른 이유:**

- **패턴 1**: `<=` + `mid ± 1` (전통적, 안전)
- **패턴 2**: `<` + `right = mid` (최적화, 효율적)

**둘 다 정답을 찾지만**, **패턴 2가 더 효율적**이고 **코드가 더 간결**합니다! 🚀
