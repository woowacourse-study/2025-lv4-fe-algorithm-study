# 📝 알고리즘 문제 풀이 - 2025-10-09

## 문제 📖

- **문제 링크:** [prog - 산 모양 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/258705)

- **문제 유형:** DP

- **난이도:** Lv.3

- **풀이 시간:** ⏳ 50분

## ✍ 접근 방식

- (어떤 방법으로 접근했는지 설명)
- (다른 풀이를 참고했다면 어떤걸 배웠는지)

초기 풀이는 아래와 같음.

```js
function solution(n, tops) {
  const topCount = tops.filter((top) => top === 1).length;
  return Math.pow(2, n - topCount) * Math.pow(3, topCount) * 2 - 1;
}
```

- 근데 틀림 왜냐
- 각 칸이 서로 독립이 아니라서 그럼.
- 지금 식 2^(n-topCount) _ 3^(topCount) _ 2 - 1 은 열(칸)마다 경우의 수를 곱셈으로 독립 처리
- 마름모 때문에 인접한 칸이 서로 의존함

즉, 앞 칸에서 뭘 놓았는지에 따라 다음 칸의 가능한 모양 수가 달라짐.
이게 바로 “칸별 독립”이 깨지는 이유고, 그래서 단순히 곱하기가 아니라 상태를 이어서 세야함.

따라서 단순 곱셈이 아닌 DP 점화식으로 풀어야함.

```js
function solution(n, tops) {
  const MOD = 10007;
  let a = 1; // i=0에서 3번으로 채운 경우
  let b = tops[0] ? 3 : 2; // i=0에서 1/2/4번으로 채운 경우

  for (let i = 1; i < n; i++) {
    const prevA = a;
    const prevB = b;

    // 세로 마름모(두 칸짜리)를 놓으면 언제나 다음 칸에 빚 생김
    a = (prevA + prevB) % MOD;

    // 한 칸 안에서 끝내는 모양 수: top에 따라 2 또는 3
    if (tops[i] === 1) {
      b = (2 * prevA + 3 * prevB) % MOD;
    } else {
      b = (1 * prevA + 2 * prevB) % MOD;
    }
  }

  return (a + b) % MOD;
}
```

- 빚 상태(a): i번째 칸을 끝냈는데, 오른쪽 칸이 반쯤 먹힌 채로 끝난 경우
- 깨끗 상태(b): i번째 칸을 끝냈는데, 다음 칸이 멀쩡히 비어 있는 경우

- “두 칸짜리(왼쪽 뾰족 마름모)”가 다음 칸을 얽어매서 독립 곱셈이 깨져요.
- 그래서 매 칸마다 “빚 상태/깨끗 상태” 두 가지만 기억해 이어가면 깔끔히 해결됩니다.
