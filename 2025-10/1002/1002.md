# 📝 알고리즘 문제 풀이 - 2025-10-02

## 문제 📖

- **문제 링크:** [prog - 합승택시 요금 ](https://school.programmers.co.kr/learn/courses/30/lessons/72413)

- **문제 유형:**

- **난이도:** lv2

- **풀이 시간:** ⏳ 60분

## ✍ 접근 방식

> 어떤 방법으로 접근했는지 설명
> 다른 풀이를 참고했다면 어떤걸 배웠는지

- 수도 코드

```js
function solution(n, s, a, b, fares) {
  // n은 3이상 200이하
  // fares 는 n * (n-1) /2
  // 1. fares 를 돌면서 2중배열에 가격을 적음. 기본 -1로 아니면 값이면 값을 넣음.
  // 2. dp 1차원 배열에서 출발지부터 하나씩 추가
  // |   | 1 | 2 | 3 | 4 | 5 | 6 |
  // | s |   |   |   | 0 |   |   |
  // | s | 10| 66|   | 0 |   | 50|
  // 3. dp[a] + dp[b] - dp[중간지점]
}
```

이 문제는 다익스트라 알고리즘 또는 플로이드-워셜 알고리즘을 사용하여 해결할 수 있음.

### 방법 A: 다익스트라 3번 (실전에서 가장 흔함)

- 무방향 가중치 그래프를 인접 리스트로 구성
- 다익스트라를 각각 s, a, b에서 한 번씩 돌려서
- distS[*], distA[*], distB[*]를 얻음
- 모든 k에 대해 distS[k] + distA[k] + distB[k]의 최소를 취함
- 복잡도: O(3 \* (E log V)) (우선순위 큐 사용). n≤200이라 아주 널널합니다.

### 방법 B: 플로이드-워셜 (구현 쉬움)

- 인접 행렬로 만들어 O(n^3) 한 번 돌리면 모든 쌍 최단거리 확보
- 이후 동일하게 모든 k에 대해 합을 최소화
- n=200이면 8백만 연산 정도라 JS도 충분히 통과함

### 문제 해결 단계

1. **초기 설정**

   - 모든 지점 간의 거리를 INF로 초기화
   - 자기 자신으로 가는 비용은 0으로 설정
   - 직접 연결된 경로는 주어진 비용으로 설정

2. **최단 경로 계산**

   - 플로이드-워셜 알고리즘으로 모든 지점 간의 최단 경로 계산
   - 경유지를 하나씩 고려하여 최단 경로 갱신

3. **최소 비용 계산**
   - 모든 지점을 경유지로 고려하여 다음 비용의 최솟값을 찾음
   - (시작점 → 경유지) + (경유지 → A) + (경유지 → B)

### 수도 코드

```js
function solution(n, s, a, b, fares) {
  // 1. 초기화
  const dist = Array(n + 1)
    .fill()
    .map(() => Array(n + 1).fill(INF));
  for (let i = 1; i <= n; i++) dist[i][i] = 0;
  fares.forEach(([u, v, w]) => {
    dist[u][v] = dist[v][u] = w;
  });

  // 2. 플로이드-워셜
  for (let k = 1; k <= n; k++) {
    for (let i = 1; i <= n; i++) {
      for (let j = 1; j <= n; j++) {
        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
      }
    }
  }

  // 3. 최소 비용 계산
  let result = INF;
  for (let k = 1; k <= n; k++) {
    result = Math.min(result, dist[s][k] + dist[k][a] + dist[k][b]);
  }
  return result;
}
```
